use crate::language::ParseError;

/// A lexical element of an s-expression.
///
/// `Expression`s are Generated by [`parse`] and consumed by
/// [`build_statement`].
///
/// [`parse`]: crate::language::parse
/// [`build_statement`]: crate::language::build_statement
#[derive(Debug)]
pub enum Expression {
    Identifier(String),
    Numeric(String),
    Literal(String),
    Operator(char),
    List(Vec<Expression>),
}

impl Expression {
    /// Returns Ok(&String) if this `Expression` is an
    /// identifier, or Err(ParseError::UnexpectedToken) otherwise.
    pub fn get_identifier(&self) -> Result<&String, ParseError> {
        match self {
            Expression::Identifier(s) => Ok(s),
            _ => Err(ParseError::UnexpectedToken),
        }
    }

    /// Returns Ok(&Vec<Expression>) if this `Expression` is an
    /// s-expression, or Err(ParseError::UnexpectedToken) otherwise.
    pub fn get_expression(&self) -> Result<&Vec<Expression>, ParseError> {
        match self {
            Expression::List(v) => Ok(v),
            _ => Err(ParseError::UnexpectedToken),
        }
    }

    /// Returns Ok(char) if this `Expression` is an
    /// operator, or Err(ParseError::UnexpectedToken) otherwise.
    pub fn get_operator(&self) -> Result<char, ParseError> {
        match self {
            Expression::Operator(c) => Ok(*c),
            _ => Err(ParseError::UnexpectedToken),
        }
    }

    /// Returns Ok(&String) if this `Expression` is a
    /// numeric, or Err(ParseError::UnexpectedToken) otherwise.
    pub fn get_numeric(&self) -> Result<&String, ParseError> {
        match self {
            Expression::Numeric(s) => Ok(s),
            _ => Err(ParseError::UnexpectedToken),
        }
    }
}
